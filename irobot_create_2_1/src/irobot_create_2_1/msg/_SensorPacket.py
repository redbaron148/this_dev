"""autogenerated by genmsg_py from SensorPacket.msg. Do not edit."""
import roslib.message
import struct

import roslib.msg

class SensorPacket(roslib.message.Message):
  _md5sum = "56f92e8d70d283e7e15aa47855e73ea7"
  _type = "irobot_create_2_1/SensorPacket"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header
bool wheeldropCaster
bool wheeldropLeft
bool wheeldropRight
bool bumpLeft
bool bumpRight
bool wall
bool cliffLeft
bool cliffFronLeft
bool cliffFrontRight
bool cliffRight
bool virtualWall
uint8 infraredByte
bool advance
bool play
int16 distance
int16 angle
uint8 chargingState
uint16 voltage
int16 current
int8 batteryTemperature
uint16 batteryCharge
uint16 batteryCapacity
uint16 wallSignal
uint16 cliffLeftSignal
uint16 cliffFrontLeftSignal
uint16 cliffFrontRightSignal
uint16 cliffRightSignal
bool homeBase
bool internalCharger
uint8 songNumber
uint8 songPlaying

================================================================================
MSG: roslib/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

"""
  __slots__ = ['header','wheeldropCaster','wheeldropLeft','wheeldropRight','bumpLeft','bumpRight','wall','cliffLeft','cliffFronLeft','cliffFrontRight','cliffRight','virtualWall','infraredByte','advance','play','distance','angle','chargingState','voltage','current','batteryTemperature','batteryCharge','batteryCapacity','wallSignal','cliffLeftSignal','cliffFrontLeftSignal','cliffFrontRightSignal','cliffRightSignal','homeBase','internalCharger','songNumber','songPlaying']
  _slot_types = ['Header','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','uint8','bool','bool','int16','int16','uint8','uint16','int16','int8','uint16','uint16','uint16','uint16','uint16','uint16','uint16','bool','bool','uint8','uint8']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.
    
    The available fields are:
       header,wheeldropCaster,wheeldropLeft,wheeldropRight,bumpLeft,bumpRight,wall,cliffLeft,cliffFronLeft,cliffFrontRight,cliffRight,virtualWall,infraredByte,advance,play,distance,angle,chargingState,voltage,current,batteryTemperature,batteryCharge,batteryCapacity,wallSignal,cliffLeftSignal,cliffFrontLeftSignal,cliffFrontRightSignal,cliffRightSignal,homeBase,internalCharger,songNumber,songPlaying
    
    @param args: complete set of field values, in .msg order
    @param kwds: use keyword arguments corresponding to message field names
    to set specific fields. 
    """
    if args or kwds:
      super(SensorPacket, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = roslib.msg._Header.Header()
      if self.wheeldropCaster is None:
        self.wheeldropCaster = False
      if self.wheeldropLeft is None:
        self.wheeldropLeft = False
      if self.wheeldropRight is None:
        self.wheeldropRight = False
      if self.bumpLeft is None:
        self.bumpLeft = False
      if self.bumpRight is None:
        self.bumpRight = False
      if self.wall is None:
        self.wall = False
      if self.cliffLeft is None:
        self.cliffLeft = False
      if self.cliffFronLeft is None:
        self.cliffFronLeft = False
      if self.cliffFrontRight is None:
        self.cliffFrontRight = False
      if self.cliffRight is None:
        self.cliffRight = False
      if self.virtualWall is None:
        self.virtualWall = False
      if self.infraredByte is None:
        self.infraredByte = 0
      if self.advance is None:
        self.advance = False
      if self.play is None:
        self.play = False
      if self.distance is None:
        self.distance = 0
      if self.angle is None:
        self.angle = 0
      if self.chargingState is None:
        self.chargingState = 0
      if self.voltage is None:
        self.voltage = 0
      if self.current is None:
        self.current = 0
      if self.batteryTemperature is None:
        self.batteryTemperature = 0
      if self.batteryCharge is None:
        self.batteryCharge = 0
      if self.batteryCapacity is None:
        self.batteryCapacity = 0
      if self.wallSignal is None:
        self.wallSignal = 0
      if self.cliffLeftSignal is None:
        self.cliffLeftSignal = 0
      if self.cliffFrontLeftSignal is None:
        self.cliffFrontLeftSignal = 0
      if self.cliffFrontRightSignal is None:
        self.cliffFrontRightSignal = 0
      if self.cliffRightSignal is None:
        self.cliffRightSignal = 0
      if self.homeBase is None:
        self.homeBase = False
      if self.internalCharger is None:
        self.internalCharger = False
      if self.songNumber is None:
        self.songNumber = 0
      if self.songPlaying is None:
        self.songPlaying = 0
    else:
      self.header = roslib.msg._Header.Header()
      self.wheeldropCaster = False
      self.wheeldropLeft = False
      self.wheeldropRight = False
      self.bumpLeft = False
      self.bumpRight = False
      self.wall = False
      self.cliffLeft = False
      self.cliffFronLeft = False
      self.cliffFrontRight = False
      self.cliffRight = False
      self.virtualWall = False
      self.infraredByte = 0
      self.advance = False
      self.play = False
      self.distance = 0
      self.angle = 0
      self.chargingState = 0
      self.voltage = 0
      self.current = 0
      self.batteryTemperature = 0
      self.batteryCharge = 0
      self.batteryCapacity = 0
      self.wallSignal = 0
      self.cliffLeftSignal = 0
      self.cliffFrontLeftSignal = 0
      self.cliffFrontRightSignal = 0
      self.cliffRightSignal = 0
      self.homeBase = False
      self.internalCharger = False
      self.songNumber = 0
      self.songPlaying = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    @param buff: buffer
    @type  buff: StringIO
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_14B2hBHhb7H4B.pack(_x.wheeldropCaster, _x.wheeldropLeft, _x.wheeldropRight, _x.bumpLeft, _x.bumpRight, _x.wall, _x.cliffLeft, _x.cliffFronLeft, _x.cliffFrontRight, _x.cliffRight, _x.virtualWall, _x.infraredByte, _x.advance, _x.play, _x.distance, _x.angle, _x.chargingState, _x.voltage, _x.current, _x.batteryTemperature, _x.batteryCharge, _x.batteryCapacity, _x.wallSignal, _x.cliffLeftSignal, _x.cliffFrontLeftSignal, _x.cliffFrontRightSignal, _x.cliffRightSignal, _x.homeBase, _x.internalCharger, _x.songNumber, _x.songPlaying))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    @param str: byte array of serialized message
    @type  str: str
    """
    try:
      if self.header is None:
        self.header = roslib.msg._Header.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 42
      (_x.wheeldropCaster, _x.wheeldropLeft, _x.wheeldropRight, _x.bumpLeft, _x.bumpRight, _x.wall, _x.cliffLeft, _x.cliffFronLeft, _x.cliffFrontRight, _x.cliffRight, _x.virtualWall, _x.infraredByte, _x.advance, _x.play, _x.distance, _x.angle, _x.chargingState, _x.voltage, _x.current, _x.batteryTemperature, _x.batteryCharge, _x.batteryCapacity, _x.wallSignal, _x.cliffLeftSignal, _x.cliffFrontLeftSignal, _x.cliffFrontRightSignal, _x.cliffRightSignal, _x.homeBase, _x.internalCharger, _x.songNumber, _x.songPlaying,) = _struct_14B2hBHhb7H4B.unpack(str[start:end])
      self.wheeldropCaster = bool(self.wheeldropCaster)
      self.wheeldropLeft = bool(self.wheeldropLeft)
      self.wheeldropRight = bool(self.wheeldropRight)
      self.bumpLeft = bool(self.bumpLeft)
      self.bumpRight = bool(self.bumpRight)
      self.wall = bool(self.wall)
      self.cliffLeft = bool(self.cliffLeft)
      self.cliffFronLeft = bool(self.cliffFronLeft)
      self.cliffFrontRight = bool(self.cliffFrontRight)
      self.cliffRight = bool(self.cliffRight)
      self.virtualWall = bool(self.virtualWall)
      self.advance = bool(self.advance)
      self.play = bool(self.play)
      self.homeBase = bool(self.homeBase)
      self.internalCharger = bool(self.internalCharger)
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    @param buff: buffer
    @type  buff: StringIO
    @param numpy: numpy python module
    @type  numpy module
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_14B2hBHhb7H4B.pack(_x.wheeldropCaster, _x.wheeldropLeft, _x.wheeldropRight, _x.bumpLeft, _x.bumpRight, _x.wall, _x.cliffLeft, _x.cliffFronLeft, _x.cliffFrontRight, _x.cliffRight, _x.virtualWall, _x.infraredByte, _x.advance, _x.play, _x.distance, _x.angle, _x.chargingState, _x.voltage, _x.current, _x.batteryTemperature, _x.batteryCharge, _x.batteryCapacity, _x.wallSignal, _x.cliffLeftSignal, _x.cliffFrontLeftSignal, _x.cliffFrontRightSignal, _x.cliffRightSignal, _x.homeBase, _x.internalCharger, _x.songNumber, _x.songPlaying))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    @param str: byte array of serialized message
    @type  str: str
    @param numpy: numpy python module
    @type  numpy: module
    """
    try:
      if self.header is None:
        self.header = roslib.msg._Header.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 42
      (_x.wheeldropCaster, _x.wheeldropLeft, _x.wheeldropRight, _x.bumpLeft, _x.bumpRight, _x.wall, _x.cliffLeft, _x.cliffFronLeft, _x.cliffFrontRight, _x.cliffRight, _x.virtualWall, _x.infraredByte, _x.advance, _x.play, _x.distance, _x.angle, _x.chargingState, _x.voltage, _x.current, _x.batteryTemperature, _x.batteryCharge, _x.batteryCapacity, _x.wallSignal, _x.cliffLeftSignal, _x.cliffFrontLeftSignal, _x.cliffFrontRightSignal, _x.cliffRightSignal, _x.homeBase, _x.internalCharger, _x.songNumber, _x.songPlaying,) = _struct_14B2hBHhb7H4B.unpack(str[start:end])
      self.wheeldropCaster = bool(self.wheeldropCaster)
      self.wheeldropLeft = bool(self.wheeldropLeft)
      self.wheeldropRight = bool(self.wheeldropRight)
      self.bumpLeft = bool(self.bumpLeft)
      self.bumpRight = bool(self.bumpRight)
      self.wall = bool(self.wall)
      self.cliffLeft = bool(self.cliffLeft)
      self.cliffFronLeft = bool(self.cliffFronLeft)
      self.cliffFrontRight = bool(self.cliffFrontRight)
      self.cliffRight = bool(self.cliffRight)
      self.virtualWall = bool(self.virtualWall)
      self.advance = bool(self.advance)
      self.play = bool(self.play)
      self.homeBase = bool(self.homeBase)
      self.internalCharger = bool(self.internalCharger)
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

_struct_I = roslib.message.struct_I
_struct_3I = struct.Struct("<3I")
_struct_14B2hBHhb7H4B = struct.Struct("<14B2hBHhb7H4B")
